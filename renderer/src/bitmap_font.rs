// Minimal bitmap font for Rust renderer
// 3x5 pixel glyphs for ASCII 32-126

pub const BITMAP_FONT_DATA: &[u8] = &[
    // Space (32)
    0x00, 0x00, 0x00, 0x00, 0x00,
    // ! (33)
    0x04, 0x04, 0x04, 0x00, 0x04,
    // " (34)
    0x0A, 0x0A, 0x00, 0x00, 0x00,
    // # (35)
    0x0A, 0x0E, 0x0A, 0x0E, 0x0A,
    // $ (36)
    0x04, 0x0C, 0x04, 0x06, 0x04,
    // % (37)
    0x08, 0x08, 0x04, 0x02, 0x02,
    // & (38)
    0x04, 0x0A, 0x04, 0x0A, 0x06,
    // ' (39)
    0x04, 0x04, 0x00, 0x00, 0x00,
    // ( (40)
    0x02, 0x04, 0x04, 0x04, 0x02,
    // ) (41)
    0x04, 0x02, 0x02, 0x02, 0x04,
    // * (42)
    0x0A, 0x04, 0x0E, 0x04, 0x0A,
    // + (43)
    0x00, 0x04, 0x0E, 0x04, 0x00,
    // , (44)
    0x00, 0x00, 0x00, 0x04, 0x08,
    // - (45)
    0x00, 0x00, 0x0E, 0x00, 0x00,
    // . (46)
    0x00, 0x00, 0x00, 0x00, 0x04,
    // / (47)
    0x02, 0x02, 0x04, 0x08, 0x08,
    // 0-9
    0x04, 0x0A, 0x0A, 0x0A, 0x04, // 0
    0x04, 0x0C, 0x04, 0x04, 0x0E, // 1
    0x0C, 0x02, 0x04, 0x08, 0x0E, // 2
    0x0E, 0x02, 0x06, 0x02, 0x0E, // 3
    0x08, 0x0A, 0x0E, 0x02, 0x02, // 4
    0x0E, 0x08, 0x0E, 0x02, 0x0E, // 5
    0x06, 0x08, 0x0E, 0x0A, 0x0E, // 6
    0x0E, 0x02, 0x02, 0x04, 0x04, // 7
    0x0E, 0x0A, 0x0E, 0x0A, 0x0E, // 8
    0x0E, 0x0A, 0x0E, 0x02, 0x0E, // 9
    // : (58)
    0x00, 0x04, 0x00, 0x04, 0x00,
    // ; (59)
    0x00, 0x04, 0x00, 0x04, 0x08,
    // < (60)
    0x02, 0x04, 0x08, 0x04, 0x02,
    // = (61)
    0x00, 0x0E, 0x00, 0x0E, 0x00,
    // > (62)
    0x08, 0x04, 0x02, 0x04, 0x08,
    // ? (63)
    0x0E, 0x02, 0x04, 0x00, 0x04,
    // @ (64)
    0x04, 0x0A, 0x0A, 0x08, 0x06,
    // A-Z
    0x04, 0x0A, 0x0E, 0x0A, 0x0A, // A
    0x0C, 0x0A, 0x0C, 0x0A, 0x0C, // B
    0x06, 0x08, 0x08, 0x08, 0x06, // C
    0x0C, 0x0A, 0x0A, 0x0A, 0x0C, // D
    0x0E, 0x08, 0x0C, 0x08, 0x0E, // E
    0x0E, 0x08, 0x0C, 0x08, 0x08, // F
    0x06, 0x08, 0x0E, 0x0A, 0x06, // G
    0x0A, 0x0A, 0x0E, 0x0A, 0x0A, // H
    0x0E, 0x04, 0x04, 0x04, 0x0E, // I
    0x0E, 0x02, 0x02, 0x0A, 0x04, // J
    0x0A, 0x0A, 0x0C, 0x0A, 0x0A, // K
    0x08, 0x08, 0x08, 0x08, 0x0E, // L
    0x0A, 0x0E, 0x0A, 0x0A, 0x0A, // M
    0x0A, 0x0A, 0x0E, 0x0A, 0x0A, // N
    0x04, 0x0A, 0x0A, 0x0A, 0x04, // O
    0x0C, 0x0A, 0x0C, 0x08, 0x08, // P
    0x04, 0x0A, 0x0A, 0x0A, 0x06, // Q
    0x0C, 0x0A, 0x0C, 0x0A, 0x0A, // R
    0x06, 0x08, 0x04, 0x02, 0x0C, // S
    0x0E, 0x04, 0x04, 0x04, 0x04, // T
    0x0A, 0x0A, 0x0A, 0x0A, 0x04, // U
    0x0A, 0x0A, 0x0A, 0x0E, 0x04, // V
    0x0A, 0x0A, 0x0A, 0x0E, 0x0A, // W
    0x0A, 0x0E, 0x04, 0x0E, 0x0A, // X
    0x0A, 0x0E, 0x04, 0x04, 0x04, // Y
    0x0E, 0x02, 0x04, 0x08, 0x0E, // Z
    // [ (91)
    0x06, 0x04, 0x04, 0x04, 0x06,
    // \ (92)
    0x08, 0x08, 0x04, 0x02, 0x02,
    // ] (93)
    0x06, 0x02, 0x02, 0x02, 0x06,
    // ^ (94)
    0x04, 0x0A, 0x00, 0x00, 0x00,
    // _ (95)
    0x00, 0x00, 0x00, 0x00, 0x0E,
];

pub fn draw_char(framebuffer: &mut [u8], width: u32, height: u32, x: i32, y: i32, c: char, r: u8, g: u8, b: u8) {
    let idx = (c as u32) as usize;
    // Only handle ASCII printable characters 32-126
    if idx < 32 || idx > 126 {
        return;
    }
    let font_idx = idx - 32;
    if font_idx >= 95 {
        return;
    }
    
    if font_idx * 5 + 5 > BITMAP_FONT_DATA.len() {
        return; // Out of bounds
    }
    let glyph = &BITMAP_FONT_DATA[font_idx * 5..(font_idx + 1) * 5];
    
    for row in 0..5 {
        let bits = glyph[row];
        for col in 0..3 {
            if (bits & (1 << (2 - col))) != 0 {
                let px = x + col as i32;
                let py = y + row as i32;
                if px >= 0 && px < width as i32 && py >= 0 && py < height as i32 {
                    let pi = ((py as u32 * width + px as u32) * 4) as usize;
                    if pi + 3 < framebuffer.len() {
                        framebuffer[pi] = r;
                        framebuffer[pi + 1] = g;
                        framebuffer[pi + 2] = b;
                        framebuffer[pi + 3] = 255;
                    }
                }
            }
        }
    }
}

/// Draw a scaled character by expanding each glyph pixel into an SxS block.
pub fn draw_char_scaled(framebuffer: &mut [u8], width: u32, height: u32, x: i32, y: i32, c: char, r: u8, g: u8, b: u8, scale: u32) {
    let idx = c as u32 as usize;
    if idx < 32 || idx > 126 {
        return;
    }
    let font_idx = idx - 32;
    if font_idx >= 95 { return; }

    if font_idx * 5 + 5 > BITMAP_FONT_DATA.len() {
        return; // missing glyphs guard
    }
    let glyph = &BITMAP_FONT_DATA[font_idx * 5..(font_idx + 1) * 5];

    if scale <= 1 {
        draw_char(framebuffer, width, height, x, y, c, r, g, b);
        return;
    }

    let fw = width as i32;
    let fh = height as i32;
    let s = scale as i32;

    for row in 0..5 {
        let bits = glyph[row];
        for col in 0..3 {
            if (bits & (1 << (2 - col))) != 0 {
                // draw s x s block for this pixel
                for sy in 0..s {
                    for sx in 0..s {
                        let px = x + col as i32 * s + sx;
                        let py = y + row as i32 * s + sy;
                        if px >= 0 && px < fw && py >= 0 && py < fh {
                            let pi = ((py as u32 * width + px as u32) * 4) as usize;
                            if pi + 3 < framebuffer.len() {
                                framebuffer[pi] = r;
                                framebuffer[pi + 1] = g;
                                framebuffer[pi + 2] = b;
                                framebuffer[pi + 3] = 255;
                            }
                        }
                    }
                }
            }
        }
    }
}
